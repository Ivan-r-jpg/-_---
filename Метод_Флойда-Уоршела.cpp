// Метод_Флойда-Уоршела.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

// Підключення бібліотек
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <conio.h>

#define INF 1000000000 // Відстань, що позначає "нескінченність"
#define N 7 // Кількість вершин у графі та розмірність матриці

void print_D(int D[N][N], int step); // Прототип функції, необхідної для виводу таблиці D на кожному кроці

void print_S(int S[N][N], int step); // Прототип функції, необхідної для виводу таблиці S на кожному кроці

int get_path(int S[N][N], int i, int j, int path[], int max_len); // Прототип функції, необхідної для прокладання шляху

void Floyd_Warshall(int D[N][N], int S[N][N]); // Прототип функції, необхідної для реалізації алгоритму Флойда-Уоршела

int main() // Головна функція програми
{
    int S[N][N], start, end, path[N], path_len;
    SetConsoleOutputCP(1251);
    printf("\n\t|--------------------------------------------------------------------------------------------------------------------------|");
    printf("\n\t|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ЗАДАЧА ПРО ВИБІР ОПТИМАЛЬНОГО МАРШРУТУ ПЕЕВЕЗЕННЯ ВАНТАЖІВ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n");
    printf("\t|--------------------------------------------------------------------------------------------------------------------------|\n\n");
    int D[N][N] = {
    {0,   19,  1, INF, INF, 10, INF},
    {19,   0, INF,  3,  1, INF, 5},
    {1, INF,  0, INF, INF,  17, INF},
    {INF,  3, INF,  0,   20, INF, 18},
    {INF, 1, INF,  20,   0,  10,  12},
    {10, INF,  17, INF,  10,  0, INF},
    {INF, 5, INF, 18,   12, INF,  0}
    };

    // Ініціалізація S
    for (int i = 0; i < N; i++) 
    {
        for (int j = 0; j < N; j++) 
        {
            if (D[i][j] != INF && i != j) 
            {
                S[i][j] = j;
            }
            else 
            {
                S[i][j] = -1;
            }

        }
    }
    // Ввід start
    printf("\n\t\t|------------------------------------------------------------------------------------------------|");
    printf("\n\t\t|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ВСТАНОВЛЕННЯ ПАРАМЕТРІВ ПРОГРАМИ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n");
    printf("\t\t|------------------------------------------------------------------------------------------------|\n\n");
    printf("\n---------------------------------------------------");
    while (1) 
    {
        printf("\nВведіть початкову вершину для пошуку шляху (1..%d): ", N);
        if (scanf_s("%d", &start) != 1) 
        {
            puts("\n[ПОМИЛКА] - Помилка вводу!"); 
            fflush(stdin);
            return 1;
        }
        if (start < 1 || start > N) 
        {
            puts("\n[УВАГА] - Такої вершини не існує. Спробуйте ще раз!");
            continue;
        }
        break;
    }

    // Ввід end
    printf("\n---------------------------------------------------\n");
    while (1) 
    {
        printf("Введіть кінцеву вершину для пошуку шляху (1..%d): ", N);
        if (scanf_s("%d", &end) != 1) 
        {
            puts("\n[ПОМИЛКА] - Помилка вводу!");
            fflush(stdin);
            return 1;
        }
        if (end < 1 || end > N) 
        {
            puts("\n[УВАГА] - Такої вершини не існує. Спробуйте ще раз!");
            continue;
        }
        break;
    }
    printf("\n---------------------------------------------------\n");
    printf("\n---------------------------\n");
    printf("Початкова матриця D0:\n");
    print_D(D, 0);
    printf("\nПочаткова матриця S0:\n");
    print_S(S, 0);
    printf("\n---------------------------\n");

	Floyd_Warshall(D, S); // Виклик функції виконання алгоритму Флойда-Уоршела

    path_len = get_path(S, start - 1, end - 1, path, N); // Виклик функції для прокладання шляху

    printf("\n\t\t|-------------------------------------------------------------------------|");
    printf("\n\t\t|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ РЕЗУЛЬТАТ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n");
    printf("\t\t|-------------------------------------------------------------------------|\n\n");
    // Вивід результату на екран
    if (D[start - 1 ][end - 1] >= INF || path_len == 0) 
    {
        printf("\n[УВАГА] - Шляху з %d у %d не існує!\n", start, end);
    }
    else 
    {
        printf("\n========================================");
        printf("\nОптимальна відстань: %d\n", D[start - 1][end - 1]);
        printf("\nМаршрут %d -> %d: ", start, end);
        for (int i = 0; i < path_len; i++) 
        {
            printf("%d", path[i] + 1);
            if (i + 1 < path_len) printf(" -> ");
        }
        printf("\n");
        }
    printf("========================================\n\n");

    return 0;
}

void print_D(int D[N][N], int step) // Визначення функції, необхідної для виводу таблиці D на кожному кроці
{
    printf("\nD%d:\n", step);
    printf("       ");
    // Друк шапки-рядка
    for (int i = 0; i < N; i++)
    {
        printf("%4d", i + 1);
    }

    printf("\n     ");
    for (int i = 0; i < 4 * N + 2; i++)
    {
        printf("-");
    }
    printf("\n");

    for (int i = 0; i < N; i++)
    {
        // Друк шапки-стовпця
        printf("%3d | ", i + 1);
        // Заповнення таблиці
        for (int j = 0; j < N; j++)
        {
            if (D[i][j] >= INF)
            {
                printf("%4s", "INF");
            }
            else
            {
                printf("%4d", D[i][j]);
            }
        }
        printf("\n");
    }
}

void print_S(int S[N][N], int step) // Визначення функції, необхідної для виводу таблиці S на кожному кроці
{
    printf("\nS%d:\n", step);
    printf("       ");
    // Друк шапки-рядка
    for (int i = 0; i < N; i++)
    {
        printf("%4d", i + 1);
    }

    printf("\n     ");
    for (int i = 0; i < 4 * N + 2; i++)
    {
        printf("-");
    }
    printf("\n");

    for (int i = 0; i < N; i++)
    {
        // Друк шапки-стовпця
        printf("%3d | ", i + 1);
        // Заповнення таблиці
        for (int j = 0; j < N; j++)
        {
            if (S[i][j] == -1)
            {
                printf("%4s", "-");
            }
            else
            {
                printf("%4d", S[i][j] + 1);
            }
        }
        printf("\n");
    }
}


int get_path(int S[N][N], int i, int j, int path[], int max_len) // Визначення функції, необхідної для прокладання шляху
{
    int len = 0;
    // Захист від виходу за межі
    if (i < 0 || i >= N || j < 0 || j >= N)
    {
        return 0;
    }
    // Захист від невизначеного шляху
    if (S[i][j] == -1)
    {
        return 0;
    }

    path[len++] = i; // Додання пройденої вершини
    while (i != j) // Цикл від початкової до кінцевої вершини
    {
        i = S[i][j]; // Перехід до наступної вершини
        if (i == -1)
        {
            return 0;
        }
        // Захист від занадто довгого шляху
        if (len >= max_len)
        {
            return 0;
        }
        path[len++] = i; // Додання вершини до загального шляху
    }
    return len; // Повернення кількості пройдених вершин
}

void Floyd_Warshall(int D[N][N], int S[N][N]) // Визначення функції, необхідної для реалізації алгоритму Флойда-Уоршела
{
    int cand;
    for (int k = 0; k < N; k++) // Цикл по кроках, по проміжних вузлах
    {
        // Внутрішній цикл
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                // Захист від складання INF + число
                if (D[i][k] < INF && D[k][j] < INF)
                {
                    cand = D[i][k] + D[k][j];
                    // Якщо знайдено оптимальне значення
                    if (cand < D[i][j])
                    {
                        // Перезапис даних
                        D[i][j] = cand;
                        S[i][j] = S[i][k];
                    }
                }
            }
        }
        printf("\n|-----------------------------------------------------------------------|");
        printf("\n|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ КРОК %d ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n", k + 1);
        printf("|-----------------------------------------------------------------------|\n\n");
        // Друк таблиць на екран
        print_D(D, k + 1);
        print_S(S, k + 1);

        printf("\nНатисніть будь-яку клавішу для продовження...\n");
        _getch(); // Очікування натискання клавіші
    }
}