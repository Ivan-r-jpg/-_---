from math import inf # Імпорт значення нескінченності з модуля math
from copy import deepcopy  # Імпорт функції deepcopy з модуля copy

INF = inf  # Ініціалізація нескінченності (аналог "М")

def row_reduce(mat):
    """
    Функція row_reduce виконує редукцію рядків.
    Аргументом функції виступає копія вкладеного оригінального списку.
    Функція повертає оновлений список та суму редукції.
    """

    n = len(mat) # Визначення довжини рядка списку
    total = 0.0 # Оголошення та ініціалізація змінної для зберігання сум редукцій

    for i in range(n): # Цикл по рядках
        vals = [mat[i][j] for j in range(n) if mat[i][j] != INF] # Прохід по стовпцях, якщо існує точне числове значення, то воно автоматично додається до масиву vals
        # Якщо список порожній
        if not vals:
            continue # Пропустити весь подальший код
        m = min(vals) # Знаходження найменшого значення у рядках
        if m != 0 and m != INF: # Якщо найменше це не нуль і рядок не викреслений
            total += m # Додання значення до суми редукцій
            for j in range(n): # Цикл по стовпцях
                if mat[i][j] != INF: # Якщо точне числове значення в стовпці існує
                    mat[i][j] -= m # Відняти від цього значення редукції

    return mat, total # Повернення результату

def col_reduce(mat):
    """
    Функція row_reduce виконує редукцію стовпців.
    Аргументом функції виступає копія вкладеного оригінального списку.
    Функція повертає оновлений список та суму редукції.
    """

    n = len(mat) # Визначення довжини рядка списку
    total = 0.0 # Оголошення та ініціалізація змінної для зберігання сум редукцій

    for j in range(n): # Цикл по стовпцях
        vals = [mat[i][j] for i in range(n) if mat[i][j] != INF] # Прохід по рядках, якщо існує точне числове значення, то воно автоматично додається до масиву vals
        # Якщо список порожній
        if not vals:
            continue # Пропустити весь подальший код
        m = min(vals) # Знаходження найменшого значення у стовпцях
        if m != 0 and m != INF: # Якщо найменше це не нуль і стовпець не викреслений
            total += m # Додання значення до суми редукцій
            for i in range(n): # Цикл по рядках
                if mat[i][j] != INF: # Якщо точне числове значення в рядку існує
                    mat[i][j] -= m # Відняти від цього значення редукції

    return mat, total # Повернення результату

def zero_rating(mat):
    """
    Функція zero_penalties для кожного нуля (i,j) рахує оцінку: min у рядку i (без j) + min у стовпці j (без i), ігноруючи INF.
    Аргументом функції виступає копія вкладеного оригінального списку.
    Повертає список кортежів (penalty, i, j).
    """

    n = len(mat) # Визначення довжини рядка списку
    result = [] # Ініціалізація порожнього списку

    for i in range(n): # Цикл по рядках
        for j in range(n): # Цикл по стовпцях
            if mat[i][j] == 0: # Якщо на шляху виявився нульовий елемент
                row_vals = [mat[i][k] for k in range(n) if k != j and mat[i][k] != INF] # Створення списку, що зберігає елементи по рядку, де міститься нульовий елемент
                col_vals = [mat[k][j] for k in range(n) if k != i and mat[k][j] != INF] # Створення списку, що зберігає елементи по стовпцю, де міститься нульовий елемент
                r_min = min(row_vals) if row_vals else INF # Знаходження мінімального елемента в списку row_vals, якщо список заповнений, в інакшому випадку - INF
                c_min = min(col_vals) if col_vals else INF # Знаходження мінімального елемента в списку col_vals, якщо список заповнений, в інакшому випадку - INF
                penalty = (0 if r_min == INF else r_min) + (0 if c_min == INF else c_min) # Створення оцінки
                result.append((penalty, i, j)) # Додання оцінки + координат до списку result

    return result # Повернення результату

def cycle_check(next_map, prev_map, u, v, n):
    """
    Функція would_create_subcycle перевіряє чи створюється цикл: якщо додати u->v, чи замкнеться цикл довжиною < n.
    Аргументами функція приймає список вхідних вершин та список вихідних вершин, вершину звідки треба рухатися u, вершину куди треба рухатися v, розмірність матриці n.
    Функція повертає True, якщо вершини не можна з'єднувати та False - якщо можна.
    """

    # Якщо вже є вихід з u або вхід у v — з'єднувати взагалі не можна
    if u in next_map or v in prev_map:
        return True

    # Якщо йти від v вперед (через next_map), чи вдаться потрапити в u
    cur = v # Позначення вершини v як поточної
    steps = 0 # Кількість пророблених кроків

    while cur in next_map: # Цикл по вершинам
        cur = next_map[cur] # Перехід до нової вершини
        steps += 1 # Збільшення кроку
        if cur == u: # Якщо вдалося знайти вершину u, то треба дивитися на довжину циклу далі
            # Повернення кроків циклу
            return (steps + 1) < n

        # Запобіжник для непередбачуваних ситуацій
        if steps > n:
            return True

    return False

def branches_and_borders(cost):
    """
    Функція solve_tsp_reduction реалізовує основний алгоритм методу гілок і меж.
    Приймає список cost: квадратна матриця вартостей (list[list[float]]), на діагоналі має бути INF (або дуже велике число).
    Повертає (route, length), де route — список вершин 0..n-1 по циклу.
    """

    n = len(cost) # Визначення довжини рядка списку
    # Перевірка чи є матриця квадратичною
    if any(len(row) != n for row in cost):
        raise ValueError("\n[ПОМИЛКА] - Матриця має бути квадратною n×n!")

    # Потрібно працювати тільки з копією "робочої" матриці
    mat = deepcopy(cost)

    # Списки для зберігання обраних дуг
    next_map = {}  # u -> v
    prev_map = {}  # v -> u

    # Нижня межа (сума редукцій), корисна для контролю
    lower_bound = 0.0

    # Основний цикл ітерацій: поки не набралося n дуг
    while len(next_map) < n:
        # Редукція рядків і стовпців
        mat, add_r = row_reduce(mat)
        mat, add_c = col_reduce(mat)
        lower_bound += (add_r + add_c)

        # Оцінки нулів
        penalties = zero_rating(mat)
        # Оброблення виключної ситуації
        if not penalties:
            raise RuntimeError("\n[ПОМИЛКА] - Немає нульових клітинок для вибору — гілка зайшла в тупик!")

        # Вибір нуля з найбільшою оцінкою
        penalties.sort(reverse=True, key=lambda x: x[0])

        chosen = None
        for pen, u, v in penalties:
            # Заборонити підцикли та дублікати входів/виходів
            if cycle_check(next_map, prev_map, u, v, n):
                continue # Якщо результат функції would_create_subcycle - True, то відбувається вихід з даної ітерації підциклу
            # Дуга повинна бути дозволена
            if mat[u][v] == INF:
                continue # Якщо ні - вихід з даної ітерації підциклу
            chosen = (pen, u, v) # Вибір
            break

        # Оброблення виключної ситуації
        if chosen is None:
            raise RuntimeError("\n[ПОМИЛКА] - Усі кандидати ведуть до підциклу/конфлікту!")

        _, u, v = chosen # Визначення значень знайденої оптимальної оцінки
        print(f"Крок {len(next_map)}: Обрано дугу {u + 1} -> {v + 1} з оцінкою {_}")

        # Фіксація дуги u->v
        next_map[u] = v
        prev_map[v] = u

        # "М" чи INF у зворотному напрямку, щоб не робити 2-цикл
        mat[v][u] = INF

        # Викреслення рядка u (інші виходи з u) та стовпця v (інші входи у v)
        for j in range(n):
            mat[u][j] = INF
        for i in range(n):
            mat[i][v] = INF

        # Про всяк випадок
        for i in range(n):
            mat[i][i] = INF

    # Відновлення маршруту
    start = 0
    route = [start]
    cur = start
    for _ in range(n - 1):
        cur = next_map[cur] # Перехід до наступної вершини
        route.append(cur)

    # Розрахунок довжини по початковій матриці cost
    length = 0.0
    for i in range(n):
        a = route[i]
        b = route[(i + 1) % n]
        w = cost[a][b]
        if w == INF:
            raise RuntimeError("\n[ПОМИЛКА] - У фінальному маршруті є заборонена дуга (INF)!")
        length += w

    return route, length

def main():
    print("\n\t|", "~" * 50, "|")
    print("\t| РОЗВ'ЯЗАННЯ ЗАДАЧІ КОМІВОЯЖЕРА МЕТОДОМ ГІЛОК І МЕЖ |")
    print("\t|", "~" * 50, "|", "\n")
    print("\nВхідна таблиця розташування населених пунктів:\n")
    C = [
        [INF, 24, 20, 16, 24, 18],
        [18, INF, 25, 18, 14, 20],
        [22, 22, INF, 22, 22, 22],
        [18, 21, 22, INF, 19, 20],
        [14, 20, 14, 21, INF, 15],
        [20, 22, 16, 18, 20, INF]
    ]
    for i in range(len(C)):
        for j in range(len(C)):
            if j == 0:
                print(f"\t\t|{str(C[i][j]):>{6}}", end=" ")
            else:
                print(f"{str(C[i][j]):>{6}}", end=" ")
        print("|")
    print("")
    route, L = branches_and_borders(C)

    print("\n\t\t\t\t\t|", "~" * 9, "|")
    print("\t\t\t\t\t| РЕЗУЛЬТАТ |")
    print("\t\t\t\t\t|", "~" * 9, "|", "\n")
    pretty = " -> ".join(str(x + 1) for x in route) + f" -> {route[0] + 1}"
    print("Маршрут:", pretty)
    print("Довжина:", L)

main() # Виклик функції main