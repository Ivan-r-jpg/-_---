def function(point):
    return ((point[0]-2)**2)+(2*(point[1])**2)-10 # Розрахунок значення функції, де x - point[0], а y - point[1]
"""
Функція function(point) необхідна для обчислення значення функції в заданій точці.
Аргументами функція приймає тип даних список.
Повертає результат обчислень. 
"""

def search_by_pattern(old_point, new_point):
    P = [] # Створення порожнього списку (масиву) P, для подальшого збереження в нього координат точки

    for i in range(len(old_point)): # Оператор циклу for, відбувається послідовний перебір по кожній координаті точки
        P.append(old_point[i]+2*(new_point[i]-old_point[i])) # Додання в порожній список (масив) обрахованого значення x та y

    return P # Результат повертається у вигляду списку - точки з координатами, що були обраховані під час "Пошуку за зразком"
"""
Функція search_by_pattern(old_point, new_point) виконує "Пошук за зразком".
Аргументами функція приймає тип даних список.
Повертає результат у вигляді списку, тобто створюється точка з новими координатами. 
"""

def exploratory_search(point, h):
    new_point = list(point) # Створення копії списку (масиву) - копії точки point, під назвою new_point

    for i in range(len(new_point)): # Оператор циклу for, відбувається послідовний перебір по кожній координаті точки

        original_value = new_point[i] # Копіювання у змінну original_value однієї з двох координат точки new_point

        current_f = function(new_point) # Обчислення поточного значення функції, необхідного для порівняння ефективності "Досліджуваного пошуку"

        new_point[i] = original_value + h # Занесення зміненого значення поточної координати на крок +h у відповідну координату копії вхідної точки
        f_plus = function(new_point) # Обчислення значення функції зі зміненою координатою та занесення результату у змінну f_plus

        if f_plus < current_f: # Умовний оператор if, відбувається порівняння значень функції з минулими (current_f) та поточними координатами (f_plus)
            continue # Якщо нерівність виконується, то відбувається перехід відразу до нової ітерації

# Якщо у разі збільшення координати точки на крок h, поточне значення функції більше за минуле, то відбувається перехід до наступного етапу - зменшення даної координати точки на крок h

        new_point[i] = original_value - h # Занесення зміненого значення поточної координати на крок -h у відповідну координату копії вхідної точки
        f_minus = function(new_point) # Обчислення значення функції зі зміненою координатою та занесення результату у змінну f_minus

        if f_minus < current_f: # Умовний оператор if, відбувається порівняння значень функції з минулими (current_f) та поточними координатами (f_minus)
            continue # Якщо нерівність виконується, то відбувається перехід відразу до нової ітерації

# Якщо у разі зменшення координати точки на крок h, поточне значення функції все одно більше за минуле, то координата точки залишається без змін

        new_point[i] = original_value # Занесення у точку new_point незміненої координати точки

    return new_point # Результат повертається у вигляді списку, тобто точки з оновленими координатами, обрахованими за процедурою "Досліджуваного пошуку"
"""
Функція exploratory_search(point, h) виконує "Досліджуваний пошук".
Аргументами функція приймає тип даних список та крок h типу float, з яким будуть змінюватися аргументи функції.
Результат функції повертається у вигляді списку - точки, з новими задовільними координатами.
"""

def process(start_point, h, epsilon):
# Оголошення та ініціалізація списків (масивів)
    b_current = list(start_point) # Створення копії списку (масиву), точки start_point у точку b_current
    b_previous = list(start_point) # Створення копії списку (масиву), точки start_point у точку b_previous
# Оголошення та ініціалізація змінних

    print(f"Значення функції в цій точці: f(x) = {function(b_current)}\n", "~" * 30)
    print("Початок обчислюваного процесу...\n", "~" * 30)
    while h > epsilon: # Оператор циклу while, цикл ітерацій виконується доти поки крок h більший за значення epsilon

        x_new = exploratory_search(b_current, h) # Виконується досліджуваний пошук, результат заноситься у змінну x_new

        if function(x_new) < function(b_current): # Умовний оператор if, порівнюється значення функцій при нових та старих координатах
            b_previous = b_current # Оновлення координат минулої точки
            b_current = x_new # Оновлення координат поточної точки

            print(f"Досліджуваний пошук...\nВдалося знайти оптимальну точку\nНова база: {b_current}\nf(x) = {function(b_current)}\n", "-" * 30)
            print("Для продовження натисніть клавішу Enter...\n", "-" * 30)
            input()

            p = search_by_pattern(b_previous, b_current) # Відбувається "Пошук за зразком", результат заноситься у новий список

            after_pattern = exploratory_search(p, h) # Відбувається ще один "Дослідницький пошук"

            if function(after_pattern) < function(b_current): # Умовний оператор if, порівнюється значення функцій після стрибку та при попередніх координатах
                b_current = after_pattern # Оновлення координат поточної точки
                print(f"Пошук за зразком...\nВдалося знайти оптимальну точку\nНова база: {b_current}, f(x) = {function(b_current)}\n", "-" * 30)
                print("Для продовження натисніть клавішу Enter...\n", "-" * 30)
                input()

# Якщо після стрибка результат невдалий, то значення кроку h залишається незмінним, а результат ігнорується

        else: # Інакше, якщо досліджуваний пошук "стоїть на місці"
            h /= 2 # Зменшення кроку h удвічі
            print(f"Досліджуваний пошук...\nОптимальну точку знайти не вдалося\nЗменшення кроку до {h}\n", "-" * 30)
            print("Для продовження натисніть клавішу Enter...\n", "-" * 30)
            input()
    print("~" * 15, "РЕЗУЛЬТАТ:", "~" * 15, "\n", f"Отже, мінімум функції (з точністю до заданого значення ε = {epsilon}) знаходиться в точці {b_current} та становить {function(b_current)}\nПри цьому h = {h} <= epsilon = {epsilon}")
"""
Функція process(start_point, h, epsilon) виконує основний алгоритм пошуку екстремуму методом Хука-Дживса.
Аргументами функція приймає тип даних список - початкову задану точку, крок h, з яким змінюється точки функції та критерій зупинки epsilon.
Функція нічого не повертає, а відразу виводить результат на екран.
"""

def main():
    start_point = [] # Оголошення списку (масиву)
    print("~" * 15, "ЗНАХОДЖЕННЯ МІНІМУМУ НЕЛІНІЙНОЇ ФУНКЦІЇ МЕТОДОМ ХУКА-ДЖИВСА", "~" * 15, "\n", "-" * 30)
    try:
        h = float(input("Введіть крок з яким буде змінюватися функція при пошуку екстремуму: "))
        while h < 0:
            h = float(input("[УВАГА] - Введіть крок з яким буде змінюватися функція при пошуку екстремуму ще раз: "))
        epsilon = float(input("Введіть критерій зупинки: "))
        while epsilon < 0:
            epsilon = float(input("[УВАГА] - Введіть критерій зупинки ще раз: "))
        print(f"ДАНО:\nРівняння: ((x-2)^2)+(2*(y^2)-10)\nКрок h = {h}\nКритерій зупинки epsilon = {epsilon}\n","-" * 30)
        print("Введіть початкову точку (x; y):")
        char_text = ['x', 'y']
        for i in range(2): # Оператор циклу for, відбувається послідовний перебір по кожній координаті точки
            num = float(input(f"Введіть координату {char_text[i]} початкової точки: ")) # Число вводиться з клавіатури
            start_point.append(num) # Число додається у кінець списку (масиву) як ще одна координат
    except ValueError:
        print("[ПОМИЛКА] - Некоректно занесені дані!")
        exit()
    print(f"Початкова точка з координатами: {start_point}", )
    process(start_point, h, epsilon) # Виклик функції, що виконує основний алгоритм знаходження мінімуму нелінійної функції без обмежень методом Хука-Дживса
"""
Функція main() є рушійною силою програми.
У даній функції задається рівняння дане за умовою 12-го варіанту та вводяться координати початкової точки, а також встановлюються початкові параметри для програми на вибір користувача.
"""

main() # Виклик головної функції програми
